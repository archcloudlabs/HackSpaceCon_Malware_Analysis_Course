#!/usr/bin/env python3
"""
Example malshare downloader code.
API can be found at: https://malshare.com/doc.php
"""

import sys
import configparser
import json
import logging
import pathlib

try:
    import requests
except ImportError as err:
    print(f"error: {err}")
    sys.exit(1)

FORMAT = '%(asctime)s %(message)s'
logging.basicConfig(format=FORMAT)
logging.basicConfig()

# By default the root logger is set to WARNING and all loggers you define
# inherit that value. Here we set the root logger to NOTSET. This logging
# level is automatically inherited by all existing and new sub-loggers
# that do not set a less verbose level.
logging.root.setLevel(logging.INFO)
log = logging.getLogger()

config = configparser.ConfigParser()
config.read("config.ini")
apikey = config.get("DEFAULT", "MALSHARE_API")

LATEST_SAMPLES_URL = "https://www.malshare.com/api.php?api_key=API_KEY&action=getlist".replace("API_KEY", apikey)
DOWNLOAD_SAMPLE_URL = "https://www.malshare.com/api.php?api_key=API_KEY&action=getfile&hash=MAL_HASH".replace("API_KEY", apikey)


def __create_path__(path="./malware"):
    _path = pathlib.Path(path)
    if _path.exists() == False:
        _path.mkdir()


def __inline_patch__(byteObj):
    """
    Patch the binary object w/ machine id that does not exist to prevent execution.
    this is optional, but given to you as a choice!

    return byte array (ELF/PE/etc...)
    """
    data = bytearray(byteObj)  # convert bytes to bytearray
    if byteObj[0:2] == b'MZ':
        log.info("Identified MZ header")

    elif byteObj[0:4] == b'\x7fELF':
        log.info("Identified ELF header - patching w/ 00")
        # data[17] = 0 # setting e_machine to None disabling execution
        # data[18] = 0 # setting e_machine to None disabling execution

    return data


def get_latest_hashes(hashAlgo="sha1"):
    """
    Grab the latest hashes (md5/sha1/sha256) from the Malshare API.

    hashAlgo: string value to indiciate the hash algorithm to use.
    return: List of hashes
    """
    latest_hashes = []
    req = requests.get(LATEST_SAMPLES_URL)
    if req.status_code == 200:
        data = json.loads(req.content)
        [latest_hashes.append((sample.get(hashAlgo))) for sample in data]
    else:
        log.error(f"Error obtaining latest hashes: {req.status_code} - {req.content}")

    return latest_hashes   # return all the hashes


def download_sample(listOfSamples: list):
    """
    Download a sample from malshare based on hash

    return: byte array to write to file
    """
    if listOfSamples is None:
        logging.error("No samples to download")
        return None

    __create_path__(path="./malware")

    for sample in listOfSamples:
        sample_url = DOWNLOAD_SAMPLE_URL.replace("MAL_HASH", sample)
        logging.info(f"Downloading: {sample}")
        try:
            req = requests.get(sample_url)
            if req.status_code == 200:
                #data = __inline_patch__(req.content)  # optional
                with open(f"./malware/{sample}", "wb") as fout:
                    fout.write(req.content)
        except requests.ConnectionError as conn_error:
            logging.error(f"Trouble making request to {sample_url} - {conn_error}")
            pass

        except requests.ConnectTimeout as conn_error:
            logging.error(f"Trouble making request to {sample_url} - {conn_error}")
            pass


if __name__ == "__main__":
    hashes = get_latest_hashes()
    download_sample(hashes)
